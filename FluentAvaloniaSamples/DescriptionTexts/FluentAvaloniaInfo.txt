<?xml version="1.0"?>
<ControlInfos>
    <ControlPage Name="Home">
        <Header1>
<![CDATA[
FluentAvalonia
]]>            
        </Header1>
        <SubHeader1>
<![CDATA[Bringing more of Fluent design and WinUI controls into Avalonia.]]>             
        </SubHeader1>
        <Header2>Getting Started</Header2>
        <SubHeader2>
<![CDATA[The 'Themes' page will explain how to get FluentAvalonia integrated into your app. NOTE: if you used a pre-1.0 release version of FluentAvalonia changes may be required as somethings have changed.]]>
        </SubHeader2>
    </ControlPage>
    
    <ControlPage Name="Themes">
        <Header>
<![CDATA[
Place the following in your App.xaml :
    Namespace for FluentAvalonia.Styling
    xmlns:sty="using:FluentAvalonia.Styling"
    
    Namespace for Controls
    xmlns:ui="using:FluentAvalonia.UI.Controls"
    xmlns:uip="using:FluentAvalonia.UI.Controls.Primitives"
    
FluentAvalonia has been made independent of Avalonia and does not require you to include a reference to adding the Fluent theme from Avalonia (more on thise below)

To include the styles for FluentAvalonia, add the following to your App.xaml (or .axaml)

    <sty:FluentAvaloniaTheme />
    
FluentAvalonia is now using the new WinUI styles that have been rolling out since November 2020. All controls in core Avalonia also have been provided a template here to provide a cohesive UX, thus making FluentAvalonia independent.

FluentAvaloniaTheme has several additional options for customizing (these work regardless of which ControlsVersion you use:

You can set the theme mode (light or dark) by setting

    RequestedTheme = "Light" or "Dark" or "HighContrast"

On Windows you can set the following: 

    UseSegoeUIOnWindows - If true (default), will replace the resource 'ContentControlThemeFontFamily' with SegoeUI on Windows 10, or Segoe UI Variable Text on Windows 11, the default Windows font.

    GetUserAccentColor - If true (default), the AccentColor resources are obtained directly from the user's perferences in Windows.

    DefaultToUserTheme - If true (default), will attempt to determine if the user currently has Light or Dark mode enabled and set the app to that theme at startup. This requires Win 10 1809 or greater. This also works with the new HighContrast theme implemented in v1.1.5
    
Runtime theme changing is also supported. When initialized, FluentAvaloniaTheme is registered into the AvaloniaLocator, so it can be easily obtained later if you desire to switch themes:

    var thm = AvaloniaLocator.Current.GetService<FluentAvaloniaTheme>();
    thm.RequestedTheme = "Light" or "Dark";
    
You can also force the native Win32 title bar to respect your app theme too (if it differs from the system), however, this is a bit more manual. Call the ForceNativeTitleBarToTheme method and pass in the window you want to change. 

    var thm = AvaloniaLocator.Current.GetService<FluentAvaloniaTheme>();
    thm.ForceNativeTitleBarToTheme(Window);


Setting a custom AccentColor is also supported. For this to work, set GetUserAccentColor to false, and specify a CustomAccentColor to FluentAvaloniaTheme. The 3 light & dark variants will be automatically generated from your specified color. HOWEVER, I perform no check to see how the custom colors work. You must test for readibility & accessibility yourself.

	AvaloniaLocator.Current.GetService<FluentAvaloniaTheme>().CustomAccentColor = Colors.Orange;

If you wish to clear a custom accent color & revert to the system on Windows, reset GetUserAccentColor to true, and set CustomAccentColor to null

	AvaloniaLocator.Current.GetService<FluentAvaloniaTheme>().GetUserAccentColor = true;
	AvaloniaLocator.Current.GetService<FluentAvaloniaTheme>().CustomAccentColor = null;
]]>            
        </Header>
    </ControlPage>
    
    <ControlPage Name="Core Controls">
        <Header>
            <![CDATA[
Most controls present in Avalonia have been restyled into the new WinUI styles. The visual update from WinUI is still a work in progress and some designs may be changed or still need updating.
The following controls are NOT included (no plans to):
CaptionButtons
Carousel
ContextMenu (use ContextFlyout instead)
EmbeddableControlRoot
Label
ManagedFileChooser
NotificationCard & WindowNotificationManager
NumericUpDown (use NumberBox)
TabStrip/TabStripItem
TitleBar
]]>
        </Header>
    </ControlPage>
    
    <ControlPage Name="Basic Controls">
        <Header>
            <![CDATA[
These are new controls offered in FluentAvalonia that fall under the generic "Basic Controls" category.
            ]]>
        </Header>
        <Control Name="Button">
           <UsageNotes>
                <![CDATA[
FluentAvalonia defines it's own Button control. Previously this was used with the Flyout implementation before being added to core Avalonia. Now the only thing it adds is showing the ":pressed" state when the Enter or Space key is pressed down for better visual feedback. This control is used within FluentAvalonia, but has it's own StyleKey to not interfere with Avalonia.Controls.Button.
]]>
           </UsageNotes>
        </Control>
                <Control Name="HyperlinkButton">
           <UsageNotes>
                <![CDATA[
Launches a link defined by 'NavigateUri' NOTE: Unlike WinUI which can launch items with 'ms-appx:///', HyperlinkButton here will NOT launch things embedded in assembly (avares://, resm:, etc.), it must be a physical Uri (file system or URL)
]]>
           </UsageNotes>
        </Control>
        <Control Name="ComboBox">
            <XamlSource>
                 <![CDATA[
<ui:ComboBox Name="EditableCB" Items="{Binding ComboBoxItems}" IsEditable="True" Width="150" />
]]>
            </XamlSource>
            <UsageNotes>
<![CDATA[
Control is still in testing. This was mostly an experiment, and some functionality may still be lacking. Editable functionality was based on the AutoCompleteBox. To bind to a specific property using the ValueMemberBinding property on the ComboBox (ValueMemberBinding="{Binding PropertyName}")
]]>
            </UsageNotes>
        </Control>
        <Control Name="SplitButton">
            <XamlSource>
                 <![CDATA[
<ui:SplitButton Content="Toggle">
    <ui:SplitButton.Flyout>
        <Flyout Placement="Bottom">
            <Grid Width="200" Height="100">
                <TextBlock Text="SplitButton Flyout!" />
            </Grid>
        </Flyout>
    </ui:SplitButton.Flyout>
</ui:SplitButton>
]]>
            </XamlSource>
        </Control>
        <Control Name="ToggleSplitButton">
            <XamlSource>
                 <![CDATA[
<ui:SplitButton Content="Toggle">
    <ui:SplitButton.Flyout>
        <Flyout Placement="Bottom">
            <Grid Width="200" Height="100">
                <TextBlock Text="ToggleSplitButton Flyout!" />
            </Grid>
        </Flyout>
    </ui:SplitButton.Flyout>
</ui:SplitButton>
]]>
            </XamlSource>
        </Control>
        <Control Name="DropDownButton">
            <XamlSource>
                 <![CDATA[
<ui:DropDownButton Content="Open DropDown">
    <ui:DropDownButton.Flyout>
        <MenuFlyout Placement="Bottom">
            <MenuItem Header="Item1">
                <MenuItem.Icon>
                    <ui:SymbolIcon Symbol="Save" />
                </MenuItem.Icon>
            </MenuItem>
            <MenuItem Header="Item2" >
                <MenuItem Header="SubItem1">
                    <MenuItem.Icon>
                        <ui:SymbolIcon Symbol="Globe" />
                    </MenuItem.Icon>
                </MenuItem>
                <MenuItem Header="SubItem2" />
                <MenuItem Header="SubItem3" />
                <MenuItem Header="SubItem4" />
            </MenuItem>
            <MenuItem Header="-" />
            <MenuItem Header="Item3">
                <MenuItem.Icon>
                    <ui:SymbolIcon Symbol="Copy" />
                </MenuItem.Icon>
                <MenuItem Header="Item3SubItem1" />
                <MenuItem Header="Item3SubItem2" />
            </MenuItem>
        </MenuFlyout>
    </ui:DropDownButton.Flyout>
</ui:DropDownButton>
]]>
            </XamlSource>
        </Control>
    </ControlPage>
    
    <ControlPage Name="DialogFlyouts">
        <Control Name="ContentDialog">
            <UsageNotes>
<![CDATA[
Use a ContentDialog to show relevant information or to provide a modal dialog experience that can show any XAML content.

The ContentDialog has been modified to show in the OverlayLayer of the window, and does not use it's own HWND/Top Level window. This makes it compatible with non-desktop Application lifetimes. Unlike WinUI, multiple ContentDialogs could be shown at the same time, so it is up to you to manage them if that happens.
]]>                 
            </UsageNotes>
        </Control>
        <Control Name="PickerFlyoutBase">
            <UsageNotes>
                <![CDATA[
PickerFlyoutBase is the base implementation for providing a Flyout that the user can select an option and confirm or dismiss the selection. The ColorPickerButton uses this, see its source for how to implement your own.
]]> 
            </UsageNotes>
        </Control>
        <Control Name="PickerFlyoutPresenter">
            <UsageNotes>
                <![CDATA[
Presenter for a PickerFlyoutBase derived control. 
]]> 
            </UsageNotes>
        </Control>
    </ControlPage>
    
    <ControlPage Name="Icons">
        <Header>
<![CDATA[
IconElements and IconSources based on the WinUI versions. However, unlike UWP/WinUI, which inserts additional FrameworkElements (TextBlock/Path/etc) to render, the versions in FluentAvalonia render themselves
IconSources can be declared once as a resource, then reused anywhere, which is ideal for when you need to use the same icon in multiple places. Each use of the icon will point to the same memory location of the icon, rather than create a new one for each like when using a standard IconElement.
For controls, like the NavigationViewItem, which require an IconElement for the Icon property, an IconSource can still be used by using an IconSourceElement and assigning the 'Symbol' property to your desired IconSource resource.
A string to icon converter exists that allows quick ways to create icons where an IconElement is required. 
Example:
<NavigationViewItem Icon="Save" />
Will automatically create a SymbolIcon with the save icon. If all fails, a FontIcon will be created with the string value.
]]>                
        </Header>
        <Control Name="SymbolIcon">
            <UsageNotes>
SymbolIcons are based on the new Fluent Icons from Microsoft, both filled and regular (unfilled) icons are included. The fonts themselves are embedded directly in the FluentAvalonia assembly and can be referenced by SymbolThemeFontFamily or SymbolThemeFontFamilyFilled. The glyphs and glyph codes are not the same as the Segoe MDL2 Assets symbol font. 
A select number of symbols are available via the Symbol enum, which you can preview below. The full list can be obtained from the Fluent Icons github repo, but will require a FontIcon or TextBlock to show.
Unlike WinUI, I've also added a FontSize property to the SymbolIcon to allow changing size. In addition, since the Fluent icons come in both filled and unfilled versions, and SymbolIcon has a 'UseFilled' property to enable the filled version (false by default).
            </UsageNotes>
        </Control>
        <Control Name="SymbolIconSource">
            <XamlSource>
<![CDATA[
<!-- Defined in Resources somewhere -->
<ui:SymbolIconSource x:Key="SaveIcon" Symbol="Save" />

<ui:NavigationViewItem>
    <ui:NavigationViewItem.Icon>
        <ui:IconSourceElement Source="{StaticResource SaveIcon}" />
    </ui:NavigationViewItem.Icon>
<ui:NavigationViewItem>
]]>                
            </XamlSource>
        </Control>
        <Control Name="FontIcon">
            <UsageNotes>
            FontIcons are basically just special TextBlocks for displaying single characters (although nothing prevents you from displaying a full string).
            </UsageNotes>
        </Control>
        <Control Name="FontIconSource">
            <XamlSource>
<![CDATA[
<!-- Defined in Resources somewhere -->
<ui:FontIconSource x:Key="TestIcon" Glyph="&#xFAAA;" FontFamily="SomeSymbolFont" />

<ui:NavigationViewItem>
    <ui:NavigationViewItem.Icon>
        <ui:IconSourceElement Source="{StaticResource TestIcon}" />
    </ui:NavigationViewItem.Icon>
<ui:NavigationViewItem>
]]>                
            </XamlSource>
        </Control>
        <Control Name="PathIcon">
			<XamlSource>
<![CDATA[
<ui:PathIcon Data="M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z" />
]]>  
			</XamlSource>
		</Control>
        <Control Name="PathIconSource">
            <XamlSource>
<![CDATA[
<!-- Defined in Resources somewhere -->
<ui:PathIconSource x:Key="TestIcon" Data="..." />

<ui:NavigationViewItem>
    <ui:NavigationViewItem.Icon>
        <ui:IconSourceElement Source="{StaticResource TestIcon}" />
    </ui:NavigationViewItem.Icon>
<ui:NavigationViewItem>
]]>                
            </XamlSource>
        </Control>
        <Control Name="BitmapIcon">
            <UsageNotes>
                <![CDATA[
NOTE: BitmapIcons require Skia to be the renderer. In order to allow the property ShowAsMonochrome, rendering of the BitmapIcons is done via Skia. If enabled, the monochrome color can be adjusted by the Foreground property.
BitmapIcon UriSource can be an avares (as in the example) or an actual file name.
]]>
            </UsageNotes>
        </Control>
        <Control Name="BitmapIconSource">
            <XamlSource>
<![CDATA[
<!-- Defined in Resources somewhere -->
<ui:BitmapIconSource x:Key="TestIcon" UriSource="..." />

<ui:NavigationViewItem>
    <ui:NavigationViewItem.Icon>
        <ui:IconSourceElement Source="{StaticResource TestIcon}" />
    </ui:NavigationViewItem.Icon>
<ui:NavigationViewItem>
]]>                
            </XamlSource>
        </Control>
        <Control Name="ImageIcon">
            <UsageNotes>
                <![CDATA[
ImageIcons differ slightly from BitmapIcon in that instead of a UriSource, they accept an Avalonia.Media.IImage which allows for greater flexibility of displaying content (almost anything really). 
]]>
            </UsageNotes>
        </Control>
        <Control Name="ImageIconSource">
            <XamlSource>
<![CDATA[
<!-- Defined in Resources somewhere -->
<ui:ImageIconSource x:Key="TestIcon" Source="..." />

<ui:NavigationViewItem>
    <ui:NavigationViewItem.Icon>
        <ui:IconSourceElement Source="{StaticResource TestIcon}" />
    </ui:NavigationViewItem.Icon>
<ui:NavigationViewItem>
]]>                
            </XamlSource>
        </Control>
    </ControlPage>
    
    <ControlPage Name="NavigationView">
        <Header>
<![CDATA[
Ahh yes, the NavigationView. This is a direct port of the WinUI version, and is an absolute nightmare (it's taken me about 6 attempts to get this to actually work). There's about 8000 lines of Xaml & C++ code to this control in WinUI, so if something goes wrong in porting, it's not always easy to track down.
The NavigationView does work though, and does support Binding (though that hasn't been fully tested). In order to bind (for best results), you'll need to set the MenuItemTemplate to wrap in a NavigationViewItem to work properly (see the DataBinding example below).
Sample pages used here are from the WinUI Xaml Controls Gallery
The control itself is quite large (the entire template is loaded regardless of the PaneDisplayMode property, and the code is a mess (on account of all the modifications Microsoft keeps doing + keeping it backwards compatible). I'm currently looking at what can be done in this version to help out, without breaking it.
Known issues:
>Adjustment for TitleBars is NOT implemented, as balancing Native vs. custom titlebars is quite difficult. This is a TODO though.
>From pre-release version: Keyboard Navigation in Pane has been improved, but may not yet work 100% like WinUI.
>Switching from Top->Left mode may cause the pane to display incorrectly. This likely due to the pane reorganizing before the pane is properly reinvalidated and everything has its correct size. Closing & reopening the pane will fix the issue.
>Selecting a subitem, then switching from Left->Top or Top->Left will result in the SelectionIndicator not showing. This is a bug in WinUI
>Items loaded first in TopOverflow or subitems in Flyout when in TopNav will keep the TopOverflow styling if switched to LeftNav mode (though this is minimal). This also occurs in the WinUI version.
>Binding errors are thrown from the NavigationView (but do not affect its usability). Not sure the issue here. One binding error comes from the SplitView control, and still not sure why that occurs (present since I wrote the control)
>DO NOT USE SelectionFollowsFocus=True with a hierarchical NavView. It's clunky in WinUI and is even worse here 
>If using binding, for best results, disable the built in SettingsItem and provide your own (if binding both MenuItems and SelectedItem) or make your ViewModel property of type 'object'. It does not work with binding (even in WinUI) if your ViewModel type for the SelectedItem can't accept being sent a NavigationViewItem upon clicking Settings. 
>Space for BackButton may still be reserved if hiding BackButton. This is a limitation in that in Avalonia we can't target Grid Row/Column defs in the styling system. This is still being investigated.
>Hiding and reshowing the SettingsItem (see API in action below) will cause the Settings Item to not show until a layout pass is triggered (resize the window, for example). This is a bug in the ItemsRepeater implementation b/c Avalonia doesn't have UpdateLayout() on controls
>Other bugs in WinUI have likely made it through...
]]>            
        </Header>
        <Control Name="NavigationViewDefault">
            <XamlSource>
<![CDATA[
<ui:NavigationView x:Name="nvSample" Height="460" PaneDisplayMode="Left">
    <ui:NavigationView.MenuItems>
        <ui:NavigationViewItem Content="Menu Item1" Tag="SamplePage1" Icon="Play" />
        <ui:NavigationViewItem Content="Menu Item2" Tag="SamplePage2" Icon="Save" />
        <ui:NavigationViewItem Content="Menu Item3" Tag="SamplePage3" Icon="Refresh" />
        <ui:NavigationViewItem Content="Menu Item4" Tag="SamplePage4" Icon="Download" />
    </ui:NavigationView.MenuItems>
</ui:NavigationView>
]]>                 
            </XamlSource>
        </Control>
        <Control Name="NavigationViewAdaptive">
            <XamlSource>
<![CDATA[
<ui:NavigationView x:Name="nvSample2" Height="460" PaneDisplayMode="Auto">
    <ui:NavigationView.MenuItems>
        <ui:NavigationViewItem Content="Menu Item1" Tag="SamplePage1" />
        <ui:NavigationViewItem Content="Menu Item2" Tag="SamplePage2" />
        <ui:NavigationViewItem Content="Menu Item3" Tag="SamplePage3" />
        <ui:NavigationViewItem Content="Menu Item4" Tag="SamplePage4" />
    </ui:NavigationView.MenuItems>
</ui:NavigationView>
]]>                 
            </XamlSource>
            <UsageNotes>
            <![CDATA[
When PaneDisplayMode=Auto, the layout of the NavigationView will adapt to the window size. Constraints can be set via the CompactModeThresholdWidth and ExpandedModeThresholdWidth properties. This will NOT switch between Top and Left Navigation modes.
]]> 
            </UsageNotes>
        </Control> 
        <Control Name="NavigationViewSelectionFollowsFocus">
            <XamlSource>
<![CDATA[
<ui:NavigationView x:Name="nvSample3" Height="460" PaneDisplayMode="Top" SelectionFollowsFocus="True">
    <ui:NavigationView.MenuItems>
        <ui:NavigationViewItem Content="Item1" Tag="SamplePage1" />
        <ui:NavigationViewItem Content="Item2" Tag="SamplePage2" />
        <ui:NavigationViewItem Content="Item3" Tag="SamplePage3" />
        <ui:NavigationViewItem Content="Item4" Tag="SamplePage4" />
    </ui:NavigationView.MenuItems>
</ui:NavigationView>
]]>                 
            </XamlSource>
            <UsageNotes>
<![CDATA[
As noted above, DO NOT use SelectionFollowsFocus=True with Hierarchical structure. It will not work as expected. This is best for simple navigation patterns.
]]> 
            </UsageNotes>
        </Control> 
        <Control Name="NavigationViewDataBinding">
            <XamlSource>
<![CDATA[
<ui:NavigationView x:Name="nvSample4" Height="460" PaneDisplayMode="LeftCompact" MenuItems="{Binding Categories}" Content="{Binding CurrentPage}" SelectedItem="{Binding SelectedCategory}">
    <ui:NavigationView.MenuItemTemplate>
        <DataTemplate DataType="{x:Type vm:Category}">
            <ui:NavigationViewItem Content="{Binding Name}" Icon="{Binding Icon}" ToolTip.Tip="{Binding ToolTip}" />
        </DataTemplate>
    </ui:NavigationView.MenuItemTemplate>
</ui:NavigationView>
]]>                 
            </XamlSource>
            <UsageNotes>
<![CDATA[
For best results when binding, your MenuItemTemplate should wrap your content in a NavigationViewItem IF your DataType is not already of type NavigationViewItemBase. However, if you do not, your DataType will be automatically wrapped in an NVI, although this is less optimal. If you are NOT binding, or are binding a list of NavigationViewItems, you DO NOT have to specify a template here, as you already are providing the expected type.
]]>                
            </UsageNotes>
        </Control>       
        
        <Control Name="NavigationViewDataHierarchical">
            <XamlSource>
<![CDATA[
<ui:NavigationView x:Name="nvSample5" PaneDisplayMode="Left" Height="460">
    <ui:NavigationView.MenuItems>
        <ui:NavigationViewItem Content="Home" Tag="SamplePage1" Icon="Home" />
        <ui:NavigationViewItem Content="Account" Tag="SamplePage2" Icon="Home">
            <ui:NavigationViewItem.MenuItems>
                <ui:NavigationViewItem Content="Mail" Icon="Mail" Tag="SamplePage3" />
                <ui:NavigationViewItem Content="Calendar" Icon="Calendar" Tag="SamplePage4" />
            </ui:NavigationViewItem.MenuItems>
        </ui:NavigationViewItem>
        <ui:NavigationViewItem Content="Document options" Tag="SamplePage3" Icon="Document" SelectsOnInvoked="False">
            <ui:NavigationViewItem.MenuItems>
                <ui:NavigationViewItem Content="Create new" Icon="New" Tag="SamplePage5" />
                <ui:NavigationViewItem Content="Upload file" Icon="Upload" Tag="SamplePage6" />
            </ui:NavigationViewItem.MenuItems>
        </ui:NavigationViewItem>
    </ui:NavigationView.MenuItems>
</ui:NavigationView>
]]>                 
            </XamlSource>
        </Control>  
        
    </ControlPage>
    
    <ControlPage Name="ColorPicker">
        <Control Name="StandardColorPicker">
            <UsageNotes>
<![CDATA[
This is one deviation I've made from WinUI, as I don't care for the design of the WinUI color picker. This one has been redesigned taking inspiration from the WinUI version, the WinUI community toolkit version, and various other color pickers in use in other software. A ColorTriangle has also been added to provide an alternative display, and all three modes can be turned on or off.
The Color property of the ColorPicker is of type FluentAvalonia.UI.Media.Color2, to handle the HSV color spectrum. Color2 is RGB, HSV, HSL, and CMYK aware and can convert between these colorspaces. This is implicitly convertible to Avalonia.Media.Color (no cast), however will not play nice with binding. Properties should be adjusted accordingly or use a converter.
NOTE: ColorPicker requires Skia to be the renderer
]]>                  
            </UsageNotes>
        </Control>
        <Control Name="ColorPickerButton">
            <XamlSource>
<![CDATA[
<ui:ColorPickerButton Name="PickerButton" Color="Lime" />
<ui:ColorPickerButton Name="PickerButton2" Color="DarkSlateBlue" ShowAcceptDismissButtons="False" />
]]>
            </XamlSource>
            <UsageNotes>
<![CDATA[
Even my compacted ColorPicker implementation may not be suitable in all UX circumstances. ColorPickerButton offers an alternative to hide the ColorPicker away in a flyout. Because ColorPicker is not the lightest of controls, all ColorPickerButtons share one instance of a Flyout containing a color picker. Because Flyouts are light dismissable this shouldn't cause any problems. Most properties on ColorPicker are present on ColorPickerButton and despite sharing, each ColorPickerButton can be configured differently (all properties are reset upon opening each button)
By default, the ColorPickerButton will not update the color until it's confirmed, but you can set the flyout to update the color in realtime by setting ShowAcceptDismissButtons=False.
]]>                  
            </UsageNotes>
        </Control>
    </ControlPage>
    
    <ControlPage Name="Frame">
        <Header>
<![CDATA[
The frame control allows for easy Navigation handling within an app, and works well with the Navigation View. The control is adapted from the WinUI and Uno version, and should operate similarly. Some animation transition effects are available.
]]>             
        </Header>
        <Control Name="Frame">
            <XamlSource>
<![CDATA[
<DockPanel>
    <StackPanel Spacing="4" Orientation="Horizontal" DockPanel.Dock="Top">
        <ui:Button Content="Go Back" Command="{Binding #TestFrame.GoBack}" IsEnabled="{Binding #TestFrame.CanGoBack}" />
        <ui:Button Content="Go Forward" Command="{Binding #TestFrame.GoForward}" IsEnabled="{Binding #TestFrame.CanGoForward}" />
    </StackPanel>

    <ui:Frame Name="TestFrame" /> 
</DockPanel>
]]> 
            </XamlSource>
            <CSharpSource>
<![CDATA[
//To Navigate to a page, where a page is any derivative of IControl:
TestFrame.Navigate(typeof(SamplePage));

//To Navigate adding a parameter:
TestFrame.Navigate(typeof(SamplePage), paramHere);

//To Navigate with a custom animation:
TestFrame.Navigate(typeof(SamplePage), paramHere, transitionInfo);

// Where transitionInfo is a NavigationTransitionInfo type
//    SlideNavigationTransitionInfo
//    EntranceNavigationTranstionInfo (default, Slide up & fade in)
//    DrillInNavigationTransitionInfo (zoom in like effect)
//    SuppressNavigationTransitionInfo (no animation)

//To Go Back:
TestFrame.GoBack();
TestFrame.GoBack(transitionInfo); //With custom transition info

//To Go Forward:
TestFrame.GoForward();
TestFrame.GoForward(transitionInfo); //With custom transtion info

//NOTE: you can also bind Button commands to the frame as in the XamlSource above.

//You can disable the Back & Forward stacks with
TestFrame.IsNavigationStackEnabled = false;

//And you can change the size of the page cache (defaults to 10)
//NOTE: pages are kept in the cache until it is filled
//And an attempt to reuse each internal entry in the cache is made for performance.
//Having the cache allows pages to reload quicker.
//Depending on page content, first time load may be slow & the animation may not play correctly
TestFrame.CacheSize = 10;
]]>                
            </CSharpSource>
            <UsageNotes>
<![CDATA[
NOTE: Because no 'Page' control exists in Avalonia like UWP/WinUI, IControl is targeted by the Frame logic. IControl does not have a method 'OnNavigatedTo' so if you need to pass a custom parameter into your page it must be done manually. Easiest way is to handle the Navigated event from Frame, get the new page from the EventArgs and pass the parameter in manually.
]]>  
            </UsageNotes>
        </Control>
    </ControlPage>
    
    <ControlPage Name="NumberBox">
        <Header>
<![CDATA[
Use NumberBox to allow users to enter algebraic equations and numeric input in your app. This control replaces the NumericUpDown in FluentAvalonia.
NOTE: The NumberBox is currently undergoing it's visual update (WinUI #5032) and will be updated here once that's finished.
]]> 
        </Header>
        <Control Name="NumberBoxExpression" />
        <Control Name="NumberBoxSpin" />
        <Control Name="NumberBoxFormat">
            <XamlSource>
<![CDATA[
<ui:NumberBox Name="FormattedNB" Header="Enter an amount:" PlaceholderText="0.00" />
]]>                          
            </XamlSource>
            <CSharpSource>
<![CDATA[
var nm = this.FindControl<NumberBox>("FormattedNB");
nm.NumberFormatter = (input) =>
{
    double increment = 1/0.25;
    return (Math.Round(input * increment, MidpointRounding.AwayFromZero) / increment).ToString("F2");
};
]]>                  
            </CSharpSource>
            <UsageNotes>
<![CDATA[

.NET doesn't have all of the culture aware formatters in the way WinUI/WinRT/UWP does, thus the NumberFormatter property has been altered to a Func<double, string> to allow custom formatting. If a function is provided, you'll receive the new Value and you return the formatted string to be displayed.
The example above rounds the number to the nearest 0.25 displayed to 2 decimal places.

NOTE: NumberFormatter is NOT an AvaloniaProperty and therefore does not support Binding.
NOTE: Returned string must still be numeric in value. No special formatting (e.g., %) is allowed.
]]>                  
            </UsageNotes>
        </Control>
    </ControlPage>
    
    <ControlPage Name="InfoBar">
        <Header>
<![CDATA[
Use an InfoBar control when a user should be informed of, acknowledge, or take action on a changed application state. By default the notification will remain in the content area until closed by the user, but will not necessarily break user flow.
]]>
        </Header>
    </ControlPage>
    <ControlPage Name="XamlUICommand">
        <Header>
<![CDATA[
An object which is used to define the look and feel of a given command, which can be reused across your app, and which is understood natively by the standard XAML controls.
]]>
        </Header>
        <XamlSource>
<![CDATA[
XamlUICommand is in the FluentAvalonia.UI.Input namespace
xmlns:input="using:FluentAvalonia.UI.Input"

Declare the Command as a resource so it can be shared:

<input:XamlUICommand x:Key="CustomXamlUICommand" ExecuteRequested="CustomXamlUICommand_ExecuteRequested" Description="This is a custom command" Label="Custom Command" HotKey="Ctrl+D">
    <input:XamlUICommand.IconSource>
        <ui:SymbolIconSource Symbol="Star" />
    </input:XamlUICommand.IconSource>
</input:XamlUICommand>

You can either handle the events manually in code behind, or bind a Command to the XamlUICommand. It works either way!

Then Attach the command:

<ui:CommandBarButton Command="{StaticResource CustomXamlUICommand}" />

]]>                          
        </XamlSource>
        <CSharpSource>
<![CDATA[
// In this case we handle the ExecuteRequested event in code behind

public void CustomXamlUICommand_ExecuteRequested(XamlUICommand sender, ExecuteRequestedEventArgs args)
{
    // Handle event here
}
]]>                  
        </CSharpSource>
        <UsageNotes>
<![CDATA[
XamlUICommand allows the sharing of the UX associated with a command. In this instance we create a simple Custom Command with a label, icon, shortcut, and description. It's defined as a resource and could be used in many controls, like this CommandBarButton. The button (and other controls) automatically get all these UI properties without the need to define the properties again.

Currently supported controls:
CommandBarButton
CommandBarToggleButton
MenuFlyoutItem

NOTE: Using hotkeys can with XamlUICommand can crash. See the StandardUICommand page for more on this, and workaround to prevent the crash.
]]>
        </UsageNotes>            
    </ControlPage>
    <ControlPage Name="StandardUICommand">
        <Header>
<![CDATA[
StandardUICommands are a set of built in XamlUICommands representing commonly used commands. Including the look and feel of a given command, which can be reused across your app, and which is understood natively by the XAML controls. E.g. Save, Open, Copy, Paste, etc.
]]>
        </Header>
        <XamlSource>
<![CDATA[
XamlUICommand is in the FluentAvalonia.UI.Input namespace
xmlns:input="using:FluentAvalonia.UI.Input"

Declare the Command as a resource so it can be shared:

<input:StandardUICommand x:Key="DeleteCommand" Kind="Delete" Command="{Binding DeleteItem}" />

You can either handle the events manually in code behind, or bind a Command to the XamlUICommand. It works either way!

Xaml inside the control example:

<StackPanel>
    <ui:CommandBar DefaultLabelPosition="Right">
        <ui:CommandBar.PrimaryCommands>
            <ui:CommandBarButton Label="Add" Command="{Binding AddItem}" />
        </ui:CommandBar.PrimaryCommands>
        <ui:CommandBar.SecondaryCommands>
            <ui:CommandBarButton Command="{StaticResource DeleteCommand}" CommandParameter="{Binding #ListBox1.SelectedItem}"/>
        </ui:CommandBar.SecondaryCommands>
    </ui:CommandBar>
    <ListBox Items="{Binding TempItems}" Name="ListBox1" VirtualizationMode="None">
        <ListBox.ItemTemplate>
            <DataTemplate>
                <Border Background="Transparent">
                    <Panel>
                        <TextBlock Text="{Binding}" VerticalAlignment="Center" />
                        <ui:CommandBarButton HorizontalAlignment="Right" Command="{StaticResource DeleteCommand}" CommandParameter="{Binding RelativeSource={RelativeSource Self}, Path=DataContext}" HotKey="{x:Null}" />
                    </Panel>

                    <Border.ContextFlyout>
                        <ui:MenuFlyout>
                            <ui:MenuFlyoutItem Command="{StaticResource DeleteCommand}" CommandParameter="{Binding #ListBox1.SelectedItem}" />
                        </ui:MenuFlyout>
                    </Border.ContextFlyout>
                </Border>
            </DataTemplate>
        </ListBox.ItemTemplate>
    </ListBox>
</StackPanel>

]]>                          
        </XamlSource>
        <CSharpSource>
<![CDATA[
// In this case, we bind the StandardUICommand to a method in our ViewModel. You can also handle in code behind, if you wish.

// List of items populating the ListBox
public AvaloniaList<string> TempItems { get; set; }

// This is our method command
public void DeleteItem(object param)
{
    if (param != null)
    {
        TempItems.Remove(param.ToString());
    }
}
]]>                  
        </CSharpSource>
        <UsageNotes>
<![CDATA[
StandardUICommand allows the sharing of the UX associated with a command. In this instance we are using a StandardUICommand to quickly place the delete command in multiple controls. The StandardUICommand contains the icon, label, keyboard shortcut, and a description.

Currently supported controls:
CommandBarButton
CommandBarToggleButton
MenuFlyoutItem

IMPORTANT NOTE: If using a XamlUICommand (including a StandardUICommand) with a hotkey set (StandardUICommand defines this) in multiple places like the example above, make sure to disable the hotkey except in one place. Hotkey's in Avalonia aren't checked to see if they're already registered and this leads to a crash.

In our example above, we set the delete command to the CommandBarButton in the CommandBar, the MenuFlyoutItem attached to each ListBoxItem, and the Delete button in each ListBoxItem. This results in a conflict when the Delete key is pressed, and will crash. Notice we clear the hotkey on the button to prevent this crash. This is workaround, not a solution to the problem.
]]>
        </UsageNotes>
    </ControlPage>
    <ControlPage Name="CommandBarButton">
        <Header>
<![CDATA[
CommandBarButtons (WinUI equivalent AppBarButton) differ from standard buttons in several ways:
- Their default appearance is a transparent background with a smaller size
- You use the Label and Icon properties to set the content instead of the Content property. The Content property is ignored.
- The button's IsCompact property controls its size

Note: While CommandBarButtons can be used outside of the CommandBar, Label on the bottom display mode is the only display mode available if not used in a CommandBar, as the CommandBar is what determines where the label displays.
]]>             
        </Header>
        <PathIconXamlSource>
<![CDATA[
<ui:CommandBarButton Label="PathIcon" Name="CBB4">
    <ui:CommandBarButton.Icon>
        <ui:PathIcon Data="F1 M 20,20L 24,10L 24,24L 5,24" />
    </ui:CommandBarButton.Icon>
</ui:CommandBarButton>
]]>             
        </PathIconXamlSource>
    </ControlPage>
    <ControlPage Name="CommandBarToggleButton">
        <Header>
<![CDATA[
A CommandBarToggleButton looks like a CommandBarButton, but works like a CheckBox. It typically has two states, checked or unchecked, but can be indeterminate. 

Note: In WinUI, indeterminate looks like checked, I don't handle that case so it looks unchecked. Neither is really ideal, so you if you require an indeterminate CommandBarToggleButton, you may need to provide some styling for that yourself.
]]>             
        </Header>
        <PathIconXamlSource>
<![CDATA[
<ui:CommandBarToggleButton Label="PathIcon" Name="CBB4">
    <ui:CommandBarToggleButton.Icon>
        <ui:PathIcon Data="F1 M 20,20L 24,10L 24,24L 5,24" />
    </ui:CommandBarToggleButton.Icon>
</ui:CommandBarToggleButton>
]]>             
        </PathIconXamlSource>
    </ControlPage>    
    <ControlPage Name="CommandBar">
        <Header>
<![CDATA[
This is an adaptation of the CommandBar from WinUI. It may not function 100% the same, but was a prerequisite for the CommandBarFlyout, so here ya go. 
Some notes:
- The CommandBar will only open down (open up is not supported)
- As in WinUI, binding to the CommandBar is not supported
- I've added a property ItemsAlignment to control the HorizontalAlignment of the PrimaryCommands.
- Adding submenu's to CommandBarButtons has limited support. It should work, but keyboard navigation probably doesn't, especially with MenuFlyouts.
- Actually, in general, Keyboard Navigation probably doesn't work the same either
- This control will receive minimal support, only in the context of something being broken. I'd rather develop a better toolbar than try to add features to a control whose general design, IMO, isn't flexible and not that great.
]]>            
        </Header>
        <DefaultXamlSource>
<![CDATA[
<ui:CommandBar>
    <ui:CommandBar.PrimaryCommands>
        <ui:CommandBarButton Icon="Save" Label="Save" />
        <ui:CommandBarButton Icon="Undo" Label="Undo" />
        <ui:CommandBarSeparator />
        <ui:CommandBarToggleButton Icon="Bold" Label="Bold" />
        <ui:CommandBarToggleButton Icon="Italic" Label="Italic" />
        <ui:CommandBarToggleButton Icon="Underline" Label="Underline" />
    </ui:CommandBar.PrimaryCommands>
    <ui:CommandBar.SecondaryCommands>
        <ui:CommandBarButton Icon="Cut" Label="Cut" />
        <ui:CommandBarButton Icon="Copy" Label="Copy" />
        <ui:CommandBarButton Icon="Paste" Label="Paste" />
    </ui:CommandBar.SecondaryCommands>
</ui:CommandBar>
]]>             
        </DefaultXamlSource>
        <RightXamlSource>
<![CDATA[
<ui:CommandBar DefaultLabelPosition="Right">
    <ui:CommandBar.PrimaryCommands>
        <ui:CommandBarButton Icon="Save" Label="Save" />
        <ui:CommandBarButton Icon="Undo" Label="Undo" />
        <ui:CommandBarSeparator />
        <ui:CommandBarToggleButton Icon="Bold" Label="Bold" />
        <ui:CommandBarToggleButton Icon="Italic" Label="Italic" />
        <ui:CommandBarToggleButton Icon="Underline" Label="Underline" />
    </ui:CommandBar.PrimaryCommands>
    <ui:CommandBar.SecondaryCommands>
        <ui:CommandBarButton Icon="Cut" Label="Cut" />
        <ui:CommandBarButton Icon="Copy" Label="Copy" />
        <ui:CommandBarButton Icon="Paste" Label="Paste" />
    </ui:CommandBar.SecondaryCommands>
</ui:CommandBar>
]]>               
        </RightXamlSource>
        <ToggleXamlSource>
<![CDATA[
<ui:CommandBar>
    <ui:CommandBar.PrimaryCommands>
        <ui:CommandBarButton Icon="Save" Label="Save" />
        <ui:CommandBarButton Icon="Undo" Label="Undo" />
        <ui:CommandBarSeparator />
        <ui:CommandBarToggleButton Icon="Bold" Label="Bold" />
        <ui:CommandBarToggleButton Icon="Italic" Label="Italic" />
        <ui:CommandBarToggleButton Icon="Underline" Label="Underline" />
    </ui:CommandBar.PrimaryCommands>
    <ui:CommandBar.SecondaryCommands>
        <ui:CommandBarButton Icon="Cut" Label="Cut" />
        <ui:CommandBarButton Icon="Copy" Label="Copy" />
        <ui:CommandBarButton Icon="Paste" Label="Paste" />
        <ui:CommandBarSeparator />
        <ui:CommandBarToggleButton Icon="Bold" Label="Bold" />
        <ui:CommandBarToggleButton Icon="Italic" Label="Italic" />
        <ui:CommandBarToggleButton Icon="Underline" Label="Underline" />
    </ui:CommandBar.SecondaryCommands>
</ui:CommandBar>
]]>   
        </ToggleXamlSource>
    </ControlPage>
    <ControlPage Name="CommandBarFlyout">
        <Header>
<![CDATA[
A mini-toolbar which displays a set of proactive commands, as well as a secondary menu of commands if desired.
Image obtained from the WinUI Xaml Controls gallery.

Like the CommandBar, this is an adaptation based on the WinUI version, so it may not function 100% correctly, but it does work. Only open down is supported. 
]]>             
        </Header>
        <XamlSource>
<![CDATA[
Flyout declared as resource:
<ui:CommandBarFlyout Placement="Right" x:Key="CommandBarFlyout1">
    <ui:CommandBarButton Label="Share" Icon="Share" ToolTip.Tip="Share" Command="{Binding Share}" />
    <ui:CommandBarButton Label="Save" Icon="Save" ToolTip.Tip="Save" Command="{Binding Save}" />
    <ui:CommandBarButton Label="Delete" Icon="Delete" ToolTip.Tip="Delete" Command="{Binding Delete}" />
    <ui:CommandBarFlyout.SecondaryCommands>
        <ui:CommandBarButton Label="Resize"  Command="{Binding Resize}" />
        <ui:CommandBarButton Label="Move" Command="{Binding Move}" />
    </ui:CommandBarFlyout.SecondaryCommands>
</ui:CommandBarFlyout>

<Button Name="myImageButton" Padding="0" Click="MyImageButton_Click">
    <Image Name="Image1" Source="/Assets/rainier.jpg" Height="300" />
</Button>
]]>             
        </XamlSource>
        <CSharpSource>
<![CDATA[
// We rely on code behind to make show the flyouts

// Add pointer released preview handler so we can launch the flyout like is a context menu/flyout
// TODO: remove this when ContextRequested is available
this.FindControl<Avalonia.Controls.Button>("myImageButton").AddHandler(PointerReleasedEvent, OnImageButtonPointerReleased, RoutingStrategies.Tunnel);

private void MyImageButton_Click(object sender, RoutedEventArgs args)
{
    ShowMenu(true);
}

private void OnImageButtonPointerReleased(object sender, PointerReleasedEventArgs e)
{
    if (e.InitialPressMouseButton == MouseButton.Right  && e.GetCurrentPoint(sender as IVisual).Properties.PointerUpdateKind == PointerUpdateKind.RightButtonReleased) 
    {
        ShowMenu(false);
        e.Handled = true;
    }
}

private void ShowMenu(bool isTransient)
{
    var flyout = Resources["CommandBarFlyout1"] as CommandBarFlyout;
    flyout.ShowMode = isTransient ? FlyoutShowMode.Transient : FlyoutShowMode.Standard;

    flyout.ShowAt(this.FindControl<Image>("Image1"));
}

]]> 
        </CSharpSource>
    </ControlPage>
    <ControlPage Name="TextCommandBarFlyout">
        <UsageNotes>
<![CDATA[
You don't specify commands for a TextCommandBarFlyout, they're automatically preset based on the controls they're attached to. It's a bit limited because we don't have rich text support yet.
TextCommandBarFlyout is the default ContextFlyout for TextBox in FluentAvalonia. It will adapt based on clipboard state, text selection, password box, etc. No Bold/Italic/Underline options are available yet, however.

TextBlocks also can be provided one to offer a 'Copy' command to copy the TextBlock's text to the clipboard. Just declare a TextCommandBarFlyout as a resource, and reference it as the TextBlock's ContextFlyout.
]]>             
        </UsageNotes>
    </ControlPage>    
    <ControlPage Name="MenuFlyout">
        <Header>
<![CDATA[
MenuFlyouts have been revamped to be more like they are in WinUI. One addition has been made...you CAN bind items to a MenuFlyout, unlike in WinUI, though this is experimental.
Following types are included:
- MenuFlyoutPresenter
- MenuFlyoutItem
- MenuFlyoutSubItem
- ToggleMenuFlyoutItem
- RadioMenuFlyoutItem

Binding with subitems requires a special template, though, see the example below for more

Note: these revamped items will not work in default menus of Avalonia, and are only supported in the MenuFlyoutPresenter included with FluentAvalonia, make sure to watch your Types!
]]>             
        </Header>
        <DefaultXamlSource>
<![CDATA[
<ui:Button Content="Click me for flyout!">
    <ui:Button.Flyout>
        <ui:MenuFlyout Placement="Bottom">
            <ui:MenuFlyoutItem Text="Item 1" Icon="Copy" />
            <ui:MenuFlyoutItem Text="Item 2" Icon="Paste" />
            <ui:MenuFlyoutSeparator />
            <ui:MenuFlyoutSubItem Text="SubMenu">
                <ui:MenuFlyoutItem Text="Subitem 1" />
                <ui:MenuFlyoutItem Text="Subitem 2" />
                <ui:MenuFlyoutItem Text="Subitem 3" />
            </ui:MenuFlyoutSubItem>
            <ui:MenuFlyoutSeparator />
            <ui:ToggleMenuFlyoutItem Text="Toggle Item" Icon="Bold" />
            <ui:MenuFlyoutSeparator />
            <ui:RadioMenuFlyoutItem Text="Radio Menu Item" IsChecked="True"
                                    GroupName="Test Group"
                                    Icon="Games"/>
            <ui:RadioMenuFlyoutItem Text="Radio Menu Item 2"
                                    Icon="Icons"
                                    GroupName="Test Group" />
        </ui:MenuFlyout>
    </ui:Button.Flyout>
</ui:Button>
]]>             
        </DefaultXamlSource>
        <BindingXamlSource>
<![CDATA[
Declare you DataTemplates corresponding to you ViewModel type, however you wish:
Note the special template needed for MenuFlyoutSubItem
<UserControl.DataTemplates>
    <DataTemplate DataType="{x:Type vm:TempMenuItem}">
        <ui:MenuFlyoutItem Text="{Binding Text}" Icon="{Binding Icon}" />
    </DataTemplate>
    <DataTemplate DataType="{x:Type vm:TempMenuSeparator}">
        <ui:MenuFlyoutSeparator />
    </DataTemplate>
    <DataTemplate DataType="{x:Type vm:TempToggleMenuItem}">
        <ui:ToggleMenuFlyoutItem IsChecked="{Binding IsChecked, Mode=TwoWay}"
                                    Text="{Binding Text}" />
    </DataTemplate>
    <DataTemplate DataType="{x:Type vm:TempRadioMenuItem}">
        <ui:RadioMenuFlyoutItem IsChecked="{Binding IsChecked, Mode=TwoWay}"
                                    Text="{Binding Text}" />
    </DataTemplate>
    <!-- You can also bind to the Icon property, using a converter to get an IconElement -->
    <ui:MenuFlyoutSubItemTemplate DataType="{x:Type vm:TempSubItem}"
                                    SubItems="{Binding SubItems}"
                                    HeaderText="{Binding Text}" />
</UserControl.DataTemplates>


Attach the flyout to your control
<ui:Button Content="Click me for flyout!">
    <ui:Button.Flyout>
        <ui:MenuFlyout Placement="Bottom"
                        Items="{Binding TestMenuItems}">
            
        </ui:MenuFlyout>
    </ui:Button.Flyout>
</ui:Button>
]]>             
        </BindingXamlSource>
    </ControlPage>   
</ControlInfos>
